document.addEventListener('DOMContentLoaded', function () {
    // Initialize the map
    const map = L.map('map', {
        center: [37.7749, -122.4194], // Default to San Francisco
        zoom: 13,
        zoomControl: true,
        attributionControl: true
    });

    // Add Mapbox tile layer
    L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=pk.eyJ1Ijoiam9nYXRldiIsImEiOiJjbWNsajl1MWgwY2ZsMm1vbTN6enJnZ245In0.Us4E9e5nunbG0G0JbQI1Bw', {
        maxZoom: 19,
        attribution: '© <a href="https://www.mapbox.com/about/maps/">Mapbox</a> © <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
        id: 'mapbox/streets-v11', // You can change to outdoors-v12, satellite-v9, etc.
        tileSize: 512,
        zoomOffset: -1,
        accessToken: 'pk.eyJ1Ijoiam9nYXRldiIsImEiOiJjbWNsajl1MWgwY2ZsMm1vbTN6enJnZ245In0.Us4E9e5nunbG0G0JbQI1Bw'
    }).addTo(map);

    // Show coordinates on mouse move
    map.on('mousemove', function (e) {
        if (window.Utils) {
            Utils.updateCoordinates(e.latlng.lat, e.latlng.lng);
        }
    });

    // Expose map for other modules
    window.routeMap = map;

    // --- Drawing Layer ---
    let drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);

    // Leaflet.draw controls
    const drawControl = new L.Control.Draw({
        edit: {
            featureGroup: drawnItems,
            remove: true
        },
        draw: {
            polyline: {
                shapeOptions: { color: '#3498db', weight: 5 },
                allowIntersection: true,
                showLength: true
            },
            polygon: {
                allowIntersection: true,
                showArea: true,
                shapeOptions: { color: '#8e44ad', weight: 4 }
            },
            rectangle: false,
            circle: false,
            marker: {
                icon: new L.Icon.Default()
            }
        }
    });
    map.addControl(drawControl);

    // Store current route state
    let currentRoute = {
        coordinates: [],
        elevations: [],
        timestamps: [],
        layer: null
    };

    // --- Drawing Events ---
    map.on(L.Draw.Event.CREATED, async function (e) {
        const layer = e.layer;
        drawnItems.clearLayers();
        drawnItems.addLayer(layer);
        if (layer instanceof L.Polyline || layer instanceof L.Polygon) {
            const coords = layer.getLatLngs();
            let flatCoords = coords;
            if (Array.isArray(coords[0])) flatCoords = coords[0];
            const latlngs = flatCoords.map(ll => [ll.lat, ll.lng]);
            lastDrawnCoords = latlngs;
            isSnapped = false;
            alignPathBtn.style.display = 'flex';
            // Don't snap yet, just show the path
            await handleRouteDraw(latlngs, { skipSnap: true });
        }
    });

    // --- Shape Templates ---
    document.querySelectorAll('.shape-btn').forEach(btn => {
        btn.addEventListener('click', async function () {
            const shape = btn.getAttribute('data-shape');
            const center = map.getCenter();
            let coords = [];
            if (window.ShapeTemplates) {
                if (shape === 'heart') coords = ShapeTemplates.heart([center.lat, center.lng]);
                if (shape === 'circle') coords = ShapeTemplates.circle([center.lat, center.lng]);
                if (shape === 'star') coords = ShapeTemplates.star([center.lat, center.lng]);
                if (shape === 'square') coords = ShapeTemplates.square([center.lat, center.lng]);
            }
            if (coords.length) {
                // Draw the shape as a polyline
                const poly = L.polyline(coords, { color: '#e67e22', weight: 5 });
                drawnItems.addLayer(poly);
                await handleRouteDraw(coords);
            }
        });
    });

    // --- Clear All ---
    document.getElementById('clearAll').addEventListener('click', function () {
        drawnItems.clearLayers();
        currentRoute = { coordinates: [], elevations: [], timestamps: [], layer: null };
        updateRouteInfo();
    });

    // --- Export GPX ---
    document.getElementById('exportGPX').addEventListener('click', function () {
        if (currentRoute.coordinates.length) {
            const gpx = GPXExport.generateGPX(
                currentRoute.coordinates,
                currentRoute.elevations,
                currentRoute.timestamps,
                { name: 'Custom Route', desc: 'Generated by Route Generator' }
            );
            GPXExport.downloadGPX(gpx, 'route.gpx');
        } else {
            Utils.updateStatus('Draw a route first!');
        }
    });

    // --- Align Path to Road Button Logic (improved) ---
    const alignPathBtn = document.getElementById('alignPathBtn');
    let lastDrawnCoords = null;
    let isSnapped = false;

    // Align Path to Road button click
    alignPathBtn.addEventListener('click', async function () {
        if (!lastDrawnCoords || !lastDrawnCoords.length) {
            Utils.updateStatus('Draw a route first!');
            return;
        }
        alignPathBtn.disabled = true;
        alignPathBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Aligning...';
        try {
            await handleRouteDraw(lastDrawnCoords, { forceSnap: true });
            isSnapped = true;
        } finally {
            alignPathBtn.disabled = false;
            alignPathBtn.innerHTML = '<i class="fas fa-route"></i> Align Path to Road';
        }
    });

    // --- Handle Route Drawing, Snapping, Elevation, and Timestamps ---
    async function handleRouteDraw(coords, options = {}) {
        Utils.showLoading('Processing route...');
        let snappedCoords = coords;
        if ((options.forceSnap || (!options.skipSnap && !isSnapped)) && window.RouteSnappingService) {
            // Use walking profile by default for best path coverage
            snappedCoords = await window.RouteSnappingService.snapToRoads(coords, { profile: 'walking' });
        }
        // Get elevation data
        let elevations = [];
        if (window.ElevationService) {
            elevations = await window.ElevationService.getElevationData(snappedCoords);
        }
        // Generate timestamps based on pace
        const pace = parseFloat(document.getElementById('avgPace')?.value) || 5.5; // min/km
        const startTime = document.getElementById('runStartTime')?.value || new Date().toISOString();
        const timestamps = generateTimestamps(snappedCoords, pace, startTime);
        // Draw the route
        drawnItems.clearLayers();
        const poly = L.polyline(snappedCoords, { color: isSnapped ? '#3498db' : '#e67e22', weight: 5 });
        drawnItems.addLayer(poly);
        // Update current route state
        currentRoute = {
            coordinates: snappedCoords,
            elevations,
            timestamps,
            layer: poly
        };
        
        // Apply loops if enabled
        if (loopRoute && loopRoute.checked) {
            updateRouteWithLoops();
        } else {
            updateRouteInfo();
        }
        
        Utils.hideLoading();
    }

    // --- Modified generateTimestamps to ensure valid date ---
    function generateTimestamps(coords, pace, startTime) {
        if (!coords.length) return [];
        let timestamps = [];
        let totalSeconds = 0;
        let prev = coords[0];
        // Ensure startTime is a valid ISO string
        let time = startTime ? new Date(startTime) : new Date();
        if (isNaN(time.getTime())) time = new Date();
        timestamps.push(time.toISOString());
        for (let i = 1; i < coords.length; i++) {
            const dist = Utils.calculateDistance(prev[0], prev[1], coords[i][0], coords[i][1]); // km
            const seconds = dist * pace * 60; // pace in min/km
            totalSeconds += seconds;
            let nextTime = new Date(time.getTime() + totalSeconds * 1000);
            timestamps.push(nextTime.toISOString());
            prev = coords[i];
        }
        return timestamps;
    }

    // --- Run Details Stats Update ---
    function updateRunStatsPanel() {
        const dist = Utils.calculateRouteDistance(currentRoute.coordinates);
        let pace = parseFloat(document.getElementById('avgPace')?.value) || 5.5;
        let duration = dist * pace; // min
        const paceUnit = document.getElementById('paceUnit')?.value || 'min/km';
        if (paceUnit === 'min/mi') {
            pace = pace * 0.621371;
            duration = dist * 0.621371 * pace;
        }
        if (document.getElementById('runStatDistance')) {
            document.getElementById('runStatDistance').textContent = dist.toFixed(2) + (paceUnit === 'min/km' ? ' km' : ' mi');
        }
        if (document.getElementById('runStatDuration')) {
            document.getElementById('runStatDuration').textContent = Utils.formatDuration(duration * 60);
        }
        if (document.getElementById('runStatElevation')) {
            document.getElementById('runStatElevation').textContent = Utils.formatElevation(Utils.calculateElevationGain(currentRoute.elevations));
        }
        if (document.getElementById('runStatPace')) {
            document.getElementById('runStatPace').textContent = parseFloat(document.getElementById('avgPace')?.value || 5.5).toFixed(2);
        }
    }

    // --- Update stats after every route change ---
    function updateRouteInfo() {
        updateRunStatsPanel();
    }

    // --- Mapbox Geocoding Search with Suggestions ---
    const mapboxToken = window.MAPBOX_TOKEN;
    const searchInput = document.getElementById('locationSearch');
    const searchBtn = document.getElementById('searchBtn');
    const suggestionsBox = document.getElementById('searchSuggestions');
    let searchResults = [];
    let activeSuggestion = -1;

    // Fetch suggestions from Mapbox Geocoding API
    async function fetchSuggestions(query) {
        if (!query) return [];
        const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(query)}.json?access_token=${mapboxToken}&autocomplete=true&limit=6`;
        const res = await fetch(url);
        if (!res.ok) return [];
        const data = await res.json();
        return data.features || [];
    }

    // Debounce utility (if not already present)
    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }

    // Add loading spinner to suggestions box
    const loadingSpinner = document.createElement('div');
    loadingSpinner.className = 'search-loading-spinner';
    loadingSpinner.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Searching...';

    // Helper: highlight matching text
    function highlightMatch(text, query) {
        if (!query) return text;
        const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'ig');
        return text.replace(regex, '<mark>$1</mark>');
    }

    // Enhanced search input event: fetch suggestions as you type
    searchInput.addEventListener('input', debounce(async function () {
        const query = searchInput.value.trim();
        if (!query) {
            suggestionsBox.style.display = 'none';
            searchResults = [];
            return;
        }
        suggestionsBox.innerHTML = '';
        suggestionsBox.appendChild(loadingSpinner);
        suggestionsBox.style.display = 'block';
        searchResults = await fetchSuggestions(query);
        activeSuggestion = -1;
        renderSuggestions(searchResults, query);
    }, 250));

    // Enhanced renderSuggestions with icon, type, ARIA, and highlight
    function renderSuggestions(suggestions, query = '') {
        suggestionsBox.innerHTML = '';
        suggestionsBox.setAttribute('role', 'listbox');
        if (!suggestions.length) {
            const noRes = document.createElement('div');
            noRes.className = 'search-no-results';
            noRes.textContent = 'No results found';
            suggestionsBox.appendChild(noRes);
            suggestionsBox.style.display = 'block';
            return;
        }
        suggestions.forEach((feature, idx) => {
            const div = document.createElement('div');
            div.className = 'search-suggestion' + (idx === activeSuggestion ? ' active' : '');
            div.setAttribute('role', 'option');
            div.setAttribute('tabindex', '-1');
            // Choose icon based on place type
            let icon = '<i class="fas fa-map-marker-alt"></i>';
            if (feature.place_type && feature.place_type[0]) {
                if (feature.place_type[0] === 'address') icon = '<i class="fas fa-home"></i>';
                if (feature.place_type[0] === 'poi') icon = '<i class="fas fa-landmark"></i>';
                if (feature.place_type[0] === 'region') icon = '<i class="fas fa-globe"></i>';
                if (feature.place_type[0] === 'locality') icon = '<i class="fas fa-city"></i>';
            }
            div.innerHTML = `${icon} <span class="search-main">${highlightMatch(feature.text, query)}</span><br><span class="search-sub">${highlightMatch(feature.place_name, query)}</span>`;
            div.addEventListener('mousedown', e => {
                e.preventDefault();
                selectSuggestion(idx);
            });
            suggestionsBox.appendChild(div);
        });
        suggestionsBox.style.display = 'block';
        // Auto-scroll to keep active suggestion in view
        setTimeout(() => {
            const active = suggestionsBox.querySelector('.search-suggestion.active');
            if (active) active.scrollIntoView({ block: 'nearest' });
        }, 0);
    }

    // Keyboard navigation for suggestions (improved)
    searchInput.addEventListener('keydown', function (e) {
        if (!searchResults.length) return;
        if (e.key === 'ArrowDown') {
            activeSuggestion = (activeSuggestion + 1) % searchResults.length;
            renderSuggestions(searchResults, searchInput.value.trim());
            e.preventDefault();
        } else if (e.key === 'ArrowUp') {
            activeSuggestion = (activeSuggestion - 1 + searchResults.length) % searchResults.length;
            renderSuggestions(searchResults, searchInput.value.trim());
            e.preventDefault();
        } else if (e.key === 'Enter' || e.key === 'Tab') {
            selectSuggestion(activeSuggestion >= 0 ? activeSuggestion : 0);
            e.preventDefault();
        } else if (e.key === 'Escape') {
            suggestionsBox.style.display = 'none';
        }
    });

    // Focus input when clicking search box
    searchInput.addEventListener('focus', function () {
        if (searchResults.length) {
            renderSuggestions(searchResults, searchInput.value.trim());
        }
    });

    // Hide suggestions when clicking outside
    document.addEventListener('mousedown', function (e) {
        if (!suggestionsBox.contains(e.target) && e.target !== searchInput) {
            suggestionsBox.style.display = 'none';
        }
    });

    // --- Run Details Controls ---
    const runStatDistance = document.getElementById('runStatDistance');
    const runStatDuration = document.getElementById('runStatDuration');
    const runStatElevation = document.getElementById('runStatElevation');
    const runStatPace = document.getElementById('runStatPace');
    const paceUnit = document.getElementById('paceUnit');
    const paceUnitLabel = document.getElementById('paceUnitLabel');
    const paceUnitLabel2 = document.getElementById('paceUnitLabel2');
    const avgPace = document.getElementById('avgPace');
    const avgPaceValue = document.getElementById('avgPaceValue');
    const paceInconsistency = document.getElementById('paceInconsistency');
    const paceInconsistencyValue = document.getElementById('paceInconsistencyValue');
    const activityTypeToggle = document.getElementById('activityTypeToggle');
    const includeHR = document.getElementById('includeHR');
    const runName = document.getElementById('runName');
    const runDate = document.getElementById('runDate');
    const runStartTime = document.getElementById('runStartTime');
    const runDesc = document.getElementById('runDesc');
    const loopRoute = document.getElementById('loopRoute');
    const loopCountGroup = document.getElementById('loopCountGroup');
    const loopCount = document.getElementById('loopCount');

    // Set today's date as default
    if (runDate) {
        const today = new Date();
        runDate.value = today.toISOString().slice(0, 10);
    }
    if (runStartTime) {
        const now = new Date();
        runStartTime.value = now.toTimeString().slice(0,5);
    }

    // Update pace unit labels
    function updatePaceUnitLabels() {
        const unit = paceUnit.value;
        paceUnitLabel.textContent = unit;
        paceUnitLabel2.textContent = unit;
    }
    if (paceUnit) {
        paceUnit.addEventListener('change', function() {
            updatePaceUnitLabels();
            if (loopRoute && loopRoute.checked && currentRoute.coordinates.length) {
                updateRouteWithLoops();
            } else {
                updateRunStatsPanel();
            }
        });
    }
    updatePaceUnitLabels();

    // Update average pace value
    if (avgPace) {
        avgPace.addEventListener('input', function() {
            avgPaceValue.textContent = parseFloat(avgPace.value).toFixed(2);
            runStatPace.textContent = parseFloat(avgPace.value).toFixed(2);
            if (loopRoute && loopRoute.checked && currentRoute.coordinates.length) {
                updateRouteWithLoops();
            } else {
                updateRunStatsPanel();
            }
        });
    }

    // Update pace inconsistency value
    if (paceInconsistency) {
        paceInconsistency.addEventListener('input', function() {
            paceInconsistencyValue.textContent = paceInconsistency.value + '%';
        });
    }

    // Sync pace slider with Route Settings pace input
    const paceInput = document.getElementById('pace');
    if (paceInput && avgPace) {
        paceInput.addEventListener('input', function() {
            avgPace.value = paceInput.value;
            avgPaceValue.textContent = parseFloat(avgPace.value).toFixed(2);
            runStatPace.textContent = parseFloat(avgPace.value).toFixed(2);
            updateRunStatsPanel();
        });
        avgPace.addEventListener('input', function() {
            paceInput.value = avgPace.value;
            if (loopRoute && loopRoute.checked && currentRoute.coordinates.length) {
                updateRouteWithLoops();
            }
        });
    }

    // Activity type toggle (Run/Bike)
    if (activityTypeToggle) {
        activityTypeToggle.addEventListener('change', function() {
            // You can add logic to change stats/labels for bike mode
            // For now, just update the color/icon
            document.querySelector('#runDetailsSection h3 i').className = activityTypeToggle.checked ? 'fas fa-biking' : 'fas fa-running';
        });
    }

    // Loop route controls
    if (loopRoute) {
        loopRoute.addEventListener('change', function() {
            loopCountGroup.style.display = this.checked ? 'block' : 'none';
            if (currentRoute.coordinates.length) {
                updateRouteWithLoops();
            }
        });
    }

    if (loopCount) {
        loopCount.addEventListener('change', function() {
            if (currentRoute.coordinates.length && loopRoute.checked) {
                updateRouteWithLoops();
            }
        });
    }

    // Function to update route with loops
    function updateRouteWithLoops() {
        if (!currentRoute.coordinates.length) return;
        
        const shouldLoop = loopRoute.checked;
        const numLoops = shouldLoop ? parseInt(loopCount.value) || 1 : 1;
        
        if (shouldLoop && numLoops > 1) {
            // Create backtracking coordinates
            const originalCoords = [...currentRoute.coordinates];
            const backtrackedCoords = [];
            
            for (let i = 0; i < numLoops; i++) {
                if (i > 0) {
                    // Add a small gap between loops (optional)
                    const lastCoord = backtrackedCoords[backtrackedCoords.length - 1];
                    const firstCoord = originalCoords[0];
                    const gapCoords = createGapCoords(lastCoord, firstCoord, 50); // 50m gap
                    backtrackedCoords.push(...gapCoords);
                }
                
                if (i % 2 === 0) {
                    // Forward direction
                    backtrackedCoords.push(...originalCoords);
                } else {
                    // Backward direction (reverse the coordinates)
                    backtrackedCoords.push(...originalCoords.slice().reverse());
                }
            }
            
            // Update current route with backtracked coordinates
            const pace = parseFloat(document.getElementById('avgPace')?.value) || 5.5;
            const startTime = document.getElementById('runStartTime')?.value || new Date().toISOString();
            const timestamps = generateTimestamps(backtrackedCoords, pace, startTime);
            
            // Get elevation data for backtracked route
            let elevations = [];
            if (window.ElevationService) {
                // Duplicate elevation data for loops, reversing for backtracking
                elevations = [...currentRoute.elevations];
                for (let i = 1; i < numLoops; i++) {
                    if (i % 2 === 0) {
                        // Forward direction - add elevation data as is
                        elevations.push(...currentRoute.elevations);
                    } else {
                        // Backward direction - reverse elevation data
                        elevations.push(...currentRoute.elevations.slice().reverse());
                    }
                }
            }
            
            // Update the route layer
            drawnItems.clearLayers();
            const poly = L.polyline(backtrackedCoords, { 
                color: isSnapped ? '#3498db' : '#e67e22', 
                weight: 5 
            });
            drawnItems.addLayer(poly);
            
            // Update current route state
            currentRoute = {
                coordinates: backtrackedCoords,
                elevations: elevations,
                timestamps: timestamps,
                layer: poly
            };
            
            updateRouteInfo();
        } else {
            // Reset to original route
            const originalCoords = currentRoute.coordinates.slice(0, Math.ceil(currentRoute.coordinates.length / (parseInt(loopCount.value) || 1)));
            const pace = parseFloat(document.getElementById('avgPace')?.value) || 5.5;
            const startTime = document.getElementById('runStartTime')?.value || new Date().toISOString();
            const timestamps = generateTimestamps(originalCoords, pace, startTime);
            
            // Get elevation data for original route
            let elevations = [];
            if (window.ElevationService) {
                elevations = currentRoute.elevations.slice(0, Math.ceil(currentRoute.elevations.length / (parseInt(loopCount.value) || 1)));
            }
            
            // Update the route layer
            drawnItems.clearLayers();
            const poly = L.polyline(originalCoords, { 
                color: isSnapped ? '#3498db' : '#e67e22', 
                weight: 5 
            });
            drawnItems.addLayer(poly);
            
            // Update current route state
            currentRoute = {
                coordinates: originalCoords,
                elevations: elevations,
                timestamps: timestamps,
                layer: poly
            };
            
            updateRouteInfo();
        }
    }

    // Helper function to create gap coordinates between loops
    function createGapCoords(startCoord, endCoord, gapDistance) {
        const gapCoords = [];
        const steps = 3; // Number of intermediate points
        
        for (let i = 1; i <= steps; i++) {
            const ratio = i / (steps + 1);
            const lat = startCoord[0] + (endCoord[0] - startCoord[0]) * ratio;
            const lng = startCoord[1] + (endCoord[1] - startCoord[1]) * ratio;
            gapCoords.push([lat, lng]);
        }
        
        return gapCoords;
    }
}); 