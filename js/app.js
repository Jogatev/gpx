document.addEventListener('DOMContentLoaded', function () {
    // Initialize the map
    const map = L.map('map', {
        center: [37.7749, -122.4194], // Default to San Francisco
        zoom: 13,
        zoomControl: true,
        attributionControl: true
    });

    // Add Mapbox tile layer
    L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=pk.eyJ1Ijoiam9nYXRldiIsImEiOiJjbWNsajl1MWgwY2ZsMm1vbTN6enJnZ245In0.Us4E9e5nunbG0G0JbQI1Bw', {
        maxZoom: 19,
        attribution: '© <a href="https://www.mapbox.com/about/maps/">Mapbox</a> © <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
        id: 'mapbox/streets-v11', // You can change to outdoors-v12, satellite-v9, etc.
        tileSize: 512,
        zoomOffset: -1,
        accessToken: 'pk.eyJ1Ijoiam9nYXRldiIsImEiOiJjbWNsajl1MWgwY2ZsMm1vbTN6enJnZ245In0.Us4E9e5nunbG0G0JbQI1Bw'
    }).addTo(map);

    // Show coordinates on mouse move
    map.on('mousemove', function (e) {
        if (window.Utils) {
            Utils.updateCoordinates(e.latlng.lat, e.latlng.lng);
        }
    });

    // Expose map for other modules
    window.routeMap = map;

    // --- Drawing Layer ---
    let drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);

    // Leaflet.draw controls
    const drawControl = new L.Control.Draw({
        edit: {
            featureGroup: drawnItems,
            remove: true
        },
        draw: {
            polyline: {
                shapeOptions: { color: '#3498db', weight: 5 },
                allowIntersection: true,
                showLength: true
            },
            polygon: {
                allowIntersection: true,
                showArea: true,
                shapeOptions: { color: '#8e44ad', weight: 4 }
            },
            rectangle: false,
            circle: false,
            marker: {
                icon: new L.Icon.Default()
            }
        }
    });
    map.addControl(drawControl);

    // Store current route state
    let currentRoute = {
        coordinates: [],
        elevations: [],
        timestamps: [],
        layer: null
    };

    // --- Drawing Events ---
    map.on(L.Draw.Event.CREATED, async function (e) {
        const layer = e.layer;
        drawnItems.clearLayers();
        drawnItems.addLayer(layer);
        if (layer instanceof L.Polyline || layer instanceof L.Polygon) {
            const coords = layer.getLatLngs();
            let flatCoords = coords;
            if (Array.isArray(coords[0])) flatCoords = coords[0];
            const latlngs = flatCoords.map(ll => [ll.lat, ll.lng]);
            lastDrawnCoords = latlngs;
            isSnapped = false;
            alignPathBtn.style.display = 'flex';
            // Don't snap yet, just show the path
            await handleRouteDraw(latlngs, { skipSnap: true });
        }
    });

    // --- Shape Templates ---
    document.querySelectorAll('.shape-btn').forEach(btn => {
        btn.addEventListener('click', async function () {
            const shape = btn.getAttribute('data-shape');
            const center = map.getCenter();
            let coords = [];
            if (window.ShapeTemplates) {
                if (shape === 'heart') coords = ShapeTemplates.heart([center.lat, center.lng]);
                if (shape === 'circle') coords = ShapeTemplates.circle([center.lat, center.lng]);
                if (shape === 'star') coords = ShapeTemplates.star([center.lat, center.lng]);
                if (shape === 'square') coords = ShapeTemplates.square([center.lat, center.lng]);
            }
            if (coords.length) {
                // Draw the shape as a polyline
                const poly = L.polyline(coords, { color: '#e67e22', weight: 5 });
                drawnItems.addLayer(poly);
                await handleRouteDraw(coords);
            }
        });
    });

    // --- Clear All ---
    document.getElementById('clearAll').addEventListener('click', function () {
        drawnItems.clearLayers();
        currentRoute = { coordinates: [], elevations: [], timestamps: [], layer: null };
        updateRouteInfo();
    });

    // --- Export GPX ---
    document.getElementById('exportGPX').addEventListener('click', function () {
        if (currentRoute.coordinates.length) {
            const gpx = GPXExport.generateGPX(
                currentRoute.coordinates,
                currentRoute.elevations,
                currentRoute.timestamps,
                { name: 'Custom Route', desc: 'Generated by Route Generator' }
            );
            GPXExport.downloadGPX(gpx, 'route.gpx');
        } else {
            Utils.updateStatus('Draw a route first!');
        }
    });

    // --- Align Path to Road Button Logic (improved) ---
    const alignPathBtn = document.getElementById('alignPathBtn');
    let lastDrawnCoords = null;
    let isSnapped = false;

    // Align Path to Road button click
    alignPathBtn.addEventListener('click', async function () {
        if (!lastDrawnCoords || !lastDrawnCoords.length) {
            Utils.updateStatus('Draw a route first!');
            return;
        }
        alignPathBtn.disabled = true;
        alignPathBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Aligning...';
        try {
            await handleRouteDraw(lastDrawnCoords, { forceSnap: true });
            isSnapped = true;
        } finally {
            alignPathBtn.disabled = false;
            alignPathBtn.innerHTML = '<i class="fas fa-route"></i> Align Path to Road';
        }
    });

    // --- Handle Route Drawing, Snapping, Elevation, and Timestamps ---
    async function handleRouteDraw(coords, options = {}) {
        Utils.showLoading('Processing route...');
        let snappedCoords = coords;
        if ((options.forceSnap || (!options.skipSnap && !isSnapped)) && window.RouteSnappingService) {
            // Use walking profile by default for best path coverage
            snappedCoords = await window.RouteSnappingService.snapToRoads(coords, { profile: 'walking' });
        }
        // Get elevation data
        let elevations = [];
        if (window.ElevationService) {
            elevations = await window.ElevationService.getElevationData(snappedCoords);
        }
        // Generate timestamps based on pace
        const pace = parseFloat(document.getElementById('avgPace')?.value) || 5.5; // min/km
        const startTime = document.getElementById('runStartTime')?.value || new Date().toISOString();
        const timestamps = generateTimestamps(snappedCoords, pace, startTime);
        // Draw the route
        drawnItems.clearLayers();
        const poly = L.polyline(snappedCoords, { color: isSnapped ? '#3498db' : '#e67e22', weight: 5 });
        drawnItems.addLayer(poly);
        // Update current route state
        currentRoute = {
            coordinates: snappedCoords,
            elevations,
            timestamps,
            layer: poly
        };
        updateRouteInfo();
        Utils.hideLoading();
    }

    // --- Modified generateTimestamps to ensure valid date ---
    function generateTimestamps(coords, pace, startTime) {
        if (!coords.length) return [];
        let timestamps = [];
        let totalSeconds = 0;
        let prev = coords[0];
        // Ensure startTime is a valid ISO string
        let time = startTime ? new Date(startTime) : new Date();
        if (isNaN(time.getTime())) time = new Date();
        timestamps.push(time.toISOString());
        for (let i = 1; i < coords.length; i++) {
            const dist = Utils.calculateDistance(prev[0], prev[1], coords[i][0], coords[i][1]); // km
            const seconds = dist * pace * 60; // pace in min/km
            totalSeconds += seconds;
            let nextTime = new Date(time.getTime() + totalSeconds * 1000);
            timestamps.push(nextTime.toISOString());
            prev = coords[i];
        }
        return timestamps;
    }

    // --- Run Details Stats Update ---
    function updateRunStatsPanel() {
        const dist = Utils.calculateRouteDistance(currentRoute.coordinates);
        let pace = parseFloat(document.getElementById('avgPace')?.value) || 5.5;
        let duration = dist * pace; // min
        const paceUnit = document.getElementById('paceUnit')?.value || 'min/km';
        if (paceUnit === 'min/mi') {
            pace = pace * 0.621371;
            duration = dist * 0.621371 * pace;
        }
        if (document.getElementById('runStatDistance')) {
            document.getElementById('runStatDistance').textContent = dist.toFixed(2) + (paceUnit === 'min/km' ? ' km' : ' mi');
        }
        if (document.getElementById('runStatDuration')) {
            document.getElementById('runStatDuration').textContent = Utils.formatDuration(duration * 60);
        }
        if (document.getElementById('runStatElevation')) {
            document.getElementById('runStatElevation').textContent = Utils.formatElevation(Utils.calculateElevationGain(currentRoute.elevations));
        }
        if (document.getElementById('runStatPace')) {
            document.getElementById('runStatPace').textContent = parseFloat(document.getElementById('avgPace')?.value || 5.5).toFixed(2);
        }
    }

    // --- Update stats after every route change ---
    function updateRouteInfo() {
        updateRunStatsPanel();
    }

    // --- Mapbox Geocoding Search with Suggestions ---
    const mapboxToken = window.MAPBOX_TOKEN;
    const searchInput = document.getElementById('locationSearch');
    const searchBtn = document.getElementById('searchBtn');
    const suggestionsBox = document.getElementById('searchSuggestions');
    let searchResults = [];
    let activeSuggestion = -1;

    // Fetch suggestions from Mapbox Geocoding API
    async function fetchSuggestions(query) {
        if (!query) return [];
        const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(query)}.json?access_token=${mapboxToken}&autocomplete=true&limit=6`;
        const res = await fetch(url);
        if (!res.ok) return [];
        const data = await res.json();
        return data.features || [];
    }

    // Add clear (X) button to search input
    const clearBtn = document.createElement('button');
    clearBtn.type = 'button';
    clearBtn.innerHTML = '<i class="fas fa-times"></i>';
    clearBtn.className = 'search-clear-btn';
    clearBtn.style.display = 'none';
    searchInput.parentNode.insertBefore(clearBtn, searchInput.nextSibling);

    searchInput.addEventListener('input', function () {
        clearBtn.style.display = searchInput.value ? 'block' : 'none';
    });
    clearBtn.addEventListener('click', function () {
        searchInput.value = '';
        clearBtn.style.display = 'none';
        suggestionsBox.style.display = 'none';
        searchInput.focus();
    });

    // Enhanced renderSuggestions with icon and type
    function renderSuggestions(suggestions) {
        suggestionsBox.innerHTML = '';
        if (!suggestions.length) {
            suggestionsBox.style.display = 'none';
            return;
        }
        suggestions.forEach((feature, idx) => {
            const div = document.createElement('div');
            div.className = 'search-suggestion' + (idx === activeSuggestion ? ' active' : '');
            // Choose icon based on place type
            let icon = '<i class="fas fa-map-marker-alt"></i>';
            if (feature.place_type && feature.place_type[0]) {
                if (feature.place_type[0] === 'address') icon = '<i class="fas fa-home"></i>';
                if (feature.place_type[0] === 'poi') icon = '<i class="fas fa-landmark"></i>';
                if (feature.place_type[0] === 'region') icon = '<i class="fas fa-globe"></i>';
                if (feature.place_type[0] === 'locality') icon = '<i class="fas fa-city"></i>';
            }
            div.innerHTML = `${icon} <span class="search-main">${feature.text}</span><br><span class="search-sub">${feature.place_name}</span>`;
            div.addEventListener('mousedown', e => {
                e.preventDefault();
                selectSuggestion(idx);
            });
            suggestionsBox.appendChild(div);
        });
        suggestionsBox.style.display = 'block';
    }

    // Select a suggestion
    function selectSuggestion(idx) {
        const feature = searchResults[idx];
        if (!feature) return;
        // Pan/zoom to location
        map.setView([feature.center[1], feature.center[0]], 16);
        // Optionally add a marker
        L.marker([feature.center[1], feature.center[0]]).addTo(map);
        // Hide suggestions
        suggestionsBox.style.display = 'none';
        searchInput.value = feature.place_name;
    }

    // On Enter or search icon, always go to the top suggestion
    searchInput.addEventListener('keydown', function (e) {
        if (!searchResults.length) return;
        if (e.key === 'Enter') {
            selectSuggestion(activeSuggestion >= 0 ? activeSuggestion : 0);
            e.preventDefault();
        }
    });
    searchBtn.addEventListener('click', async function () {
        const query = searchInput.value.trim();
        if (!query) return;
        searchResults = await fetchSuggestions(query);
        if (searchResults.length) {
            selectSuggestion(0);
        }
    });

    // Hide suggestions when clicking outside
    document.addEventListener('mousedown', function (e) {
        if (!suggestionsBox.contains(e.target) && e.target !== searchInput) {
            suggestionsBox.style.display = 'none';
        }
    });

    // --- Run Details Controls ---
    const runStatDistance = document.getElementById('runStatDistance');
    const runStatDuration = document.getElementById('runStatDuration');
    const runStatElevation = document.getElementById('runStatElevation');
    const runStatPace = document.getElementById('runStatPace');
    const paceUnit = document.getElementById('paceUnit');
    const paceUnitLabel = document.getElementById('paceUnitLabel');
    const paceUnitLabel2 = document.getElementById('paceUnitLabel2');
    const avgPace = document.getElementById('avgPace');
    const avgPaceValue = document.getElementById('avgPaceValue');
    const paceInconsistency = document.getElementById('paceInconsistency');
    const paceInconsistencyValue = document.getElementById('paceInconsistencyValue');
    const activityTypeToggle = document.getElementById('activityTypeToggle');
    const includeHR = document.getElementById('includeHR');
    const runName = document.getElementById('runName');
    const runDate = document.getElementById('runDate');
    const runStartTime = document.getElementById('runStartTime');
    const runDesc = document.getElementById('runDesc');

    // Set today's date as default
    if (runDate) {
        const today = new Date();
        runDate.value = today.toISOString().slice(0, 10);
    }
    if (runStartTime) {
        const now = new Date();
        runStartTime.value = now.toTimeString().slice(0,5);
    }

    // Update pace unit labels
    function updatePaceUnitLabels() {
        const unit = paceUnit.value;
        paceUnitLabel.textContent = unit;
        paceUnitLabel2.textContent = unit;
    }
    if (paceUnit) {
        paceUnit.addEventListener('change', function() {
            updatePaceUnitLabels();
            updateRunStatsPanel();
        });
    }
    updatePaceUnitLabels();

    // Update average pace value
    if (avgPace) {
        avgPace.addEventListener('input', function() {
            avgPaceValue.textContent = parseFloat(avgPace.value).toFixed(2);
            runStatPace.textContent = parseFloat(avgPace.value).toFixed(2);
            updateRunStatsPanel();
        });
    }

    // Update pace inconsistency value
    if (paceInconsistency) {
        paceInconsistency.addEventListener('input', function() {
            paceInconsistencyValue.textContent = paceInconsistency.value + '%';
        });
    }

    // Sync pace slider with Route Settings pace input
    const paceInput = document.getElementById('pace');
    if (paceInput && avgPace) {
        paceInput.addEventListener('input', function() {
            avgPace.value = paceInput.value;
            avgPaceValue.textContent = parseFloat(avgPace.value).toFixed(2);
            runStatPace.textContent = parseFloat(avgPace.value).toFixed(2);
            updateRunStatsPanel();
        });
        avgPace.addEventListener('input', function() {
            paceInput.value = avgPace.value;
        });
    }

    // Activity type toggle (Run/Bike)
    if (activityTypeToggle) {
        activityTypeToggle.addEventListener('change', function() {
            // You can add logic to change stats/labels for bike mode
            // For now, just update the color/icon
            document.querySelector('#runDetailsSection h3 i').className = activityTypeToggle.checked ? 'fas fa-biking' : 'fas fa-running';
        });
    }
}); 